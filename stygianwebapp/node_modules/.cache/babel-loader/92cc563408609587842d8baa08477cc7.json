{"ast":null,"code":"import { combineReducers } from 'redux'; //**initial state constants**\n\nconst im = [{\n  name: \"Turtle\",\n  content: \"When did you change my username??\"\n}, {\n  name: \"Driz\",\n  content: \"Just now. Why?\"\n}, {\n  name: \"Turtle\",\n  content: \"Urg. Nevermind that, did you hear about the news? Apparently..\"\n}, {\n  name: \"Driz\",\n  content: \"That we're all fictional? Yeah, no biggie.\"\n}];\nconst initialForm = {\n  v1: \"\",\n  v2: \"\"\n}; //**Reducers**\n\nconst messageReducer = (messageList = im, action) => {\n  //TODO: add more actions that reducer computes on; figure out if initialize_messages is correct\n  switch (action.type) {\n    case \"INITIALIZE\":\n      return action.initial_msgs = messageList.slice();\n    //DEBUG\n\n    case \"ADD_MESSAGES\":\n      break;\n\n    default:\n      return messageList;\n  }\n};\n\nconst formReducer = (f = initialForm, action) => {\n  switch (action.type) {\n    case \"HANDLE_SUBMIT\":\n      //submit\n      break;\n    //TODO\n\n    case \"HANDLE_USER\":\n      //creating a copy wiht object.assign(), not mutating the original state\n      return Object.assign({}, f, {\n        v1: action.value\n      });\n    //THIS NEEDS TO KEEP TRACK OF INPUT\n    //TODO: add another handlechange for separate text input\n\n    case \"HANDLE_MSG\":\n      return Object.assign({}, f, {\n        v2: action.value\n      });\n\n    default:\n      return f;\n  }\n};\n\nexport default combineReducers({\n  //Todo: messageList not connected to rest action, state, etc\n  messageList: messageReducer,\n  f: formReducer //anotherKey: anotherReducer //all your reducers should be combined\n\n});","map":{"version":3,"sources":["C:/Users/lydia/OneDrive/Documents/UBC/CPSC436I/assignment_2/src/reducers/index.js"],"names":["combineReducers","im","name","content","initialForm","v1","v2","messageReducer","messageList","action","type","initial_msgs","slice","formReducer","f","Object","assign","value"],"mappings":"AAAA,SAAQA,eAAR,QAA+B,OAA/B,C,CAEA;;AAEA,MAAMC,EAAE,GAAG,CACT;AACIC,EAAAA,IAAI,EAAE,QADV;AAEIC,EAAAA,OAAO,EAAE;AAFb,CADS,EAKT;AACID,EAAAA,IAAI,EAAE,MADV;AAEIC,EAAAA,OAAO,EAAE;AAFb,CALS,EAST;AACID,EAAAA,IAAI,EAAE,QADV;AAEIC,EAAAA,OAAO,EAAE;AAFb,CATS,EAaT;AACID,EAAAA,IAAI,EAAE,MADV;AAEIC,EAAAA,OAAO,EAAE;AAFb,CAbS,CAAX;AAmBA,MAAMC,WAAW,GAAG;AAClBC,EAAAA,EAAE,EAAE,EADc;AAElBC,EAAAA,EAAE,EAAE;AAFc,CAApB,C,CAOA;;AAEA,MAAMC,cAAc,GAAG,CAAEC,WAAW,GAAGP,EAAhB,EAAoBQ,MAApB,KAA+B;AACnD;AACA,UAAQA,MAAM,CAACC,IAAf;AACE,SAAK,YAAL;AACE,aAAOD,MAAM,CAACE,YAAP,GAAsBH,WAAW,CAACI,KAAZ,EAA7B;AAAkD;;AAEpD,SAAK,cAAL;AACE;;AACF;AAAS,aAAOJ,WAAP;AANX;AAQF,CAVD;;AAcA,MAAMK,WAAW,GAAG,CAAEC,CAAC,GAAGV,WAAN,EAAmBK,MAAnB,KAA8B;AACjD,UAAQA,MAAM,CAACC,IAAf;AACC,SAAK,eAAL;AACI;AACA;AACA;;AAIJ,SAAK,aAAL;AACI;AACA,aAAOK,MAAM,CAACC,MAAP,CAAc,EAAd,EAAiBF,CAAjB,EAAoB;AACzBT,QAAAA,EAAE,EAAEI,MAAM,CAACQ;AADc,OAApB,CAAP;AAEK;AAEP;;AACF,SAAK,YAAL;AACG,aAAOF,MAAM,CAACC,MAAP,CAAc,EAAd,EAAiBF,CAAjB,EAAoB;AACxBR,QAAAA,EAAE,EAAEG,MAAM,CAACQ;AADa,OAApB,CAAP;;AAID;AAAS,aAAOH,CAAP;AApBZ;AAuBA,CAxBD;;AA0BA,eAAed,eAAe,CAAC;AAC7B;AACAQ,EAAAA,WAAW,EAAED,cAFgB;AAG7BO,EAAAA,CAAC,EAAED,WAH0B,CAK/B;;AAL+B,CAAD,CAA9B","sourcesContent":["import {combineReducers } from 'redux';\n\n//**initial state constants**\n\nconst im = [\n  {\n      name: \"Turtle\",\n      content: \"When did you change my username??\"\n  },\n  {\n      name: \"Driz\",\n      content: \"Just now. Why?\"\n  },\n  {\n      name: \"Turtle\",\n      content: \"Urg. Nevermind that, did you hear about the news? Apparently..\"\n  },\n  {\n      name: \"Driz\",\n      content: \"That we're all fictional? Yeah, no biggie.\"\n  }\n];\n\nconst initialForm = {\n  v1: \"\",\n  v2: \"\"\n}\n\n\n\n//**Reducers**\n\nconst messageReducer = ( messageList = im, action) => {\n   //TODO: add more actions that reducer computes on; figure out if initialize_messages is correct\n   switch (action.type){\n     case \"INITIALIZE\":\n       return action.initial_msgs = messageList.slice(); //DEBUG\n      \n     case \"ADD_MESSAGES\":\n       break;\n     default: return messageList;\n    } \n};\n\n\n\nconst formReducer = ( f = initialForm, action) => {\n switch (action.type){\n  case \"HANDLE_SUBMIT\":\n      //submit\n      break;\n      //TODO\n\n\n    \n  case \"HANDLE_USER\":\n      //creating a copy wiht object.assign(), not mutating the original state\n      return Object.assign({},f, {\n        v1: action.value\n      });  //THIS NEEDS TO KEEP TRACK OF INPUT\n    \n    //TODO: add another handlechange for separate text input\n  case \"HANDLE_MSG\":\n     return Object.assign({},f, {\n        v2: action.value\n      }); \n    \n    default: return f; \n }\n \n};\n \nexport default combineReducers({\n  //Todo: messageList not connected to rest action, state, etc\n  messageList: messageReducer,\n  f: formReducer\n \n//anotherKey: anotherReducer //all your reducers should be combined\n});\n\n"]},"metadata":{},"sourceType":"module"}